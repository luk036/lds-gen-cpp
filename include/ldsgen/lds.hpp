#pragma once

#include <array>
#include <atomic>
#include <cmath>
#include <cstddef>

#ifndef M_PI
#    define M_PI 3.14159265358979323846264338327950288
#endif

namespace ldsgen {

    constexpr const auto TWO_PI = 2.0 * M_PI;

    // Constants for magic numbers
    constexpr size_t MAX_REVERSE_BITS = 64;
    constexpr double MAPPING_FACTOR = 2.0;

    /**
     * @brief Van der Corput sequence
     *
     * The `vdc` function is calculating the Van der Corput sequence value for a
     * given index `count` and base `base`. It returns a `double` value.
     *
     * ```svgbob
     *     Base 2 Example:
     *     count=1 -> 0.5  (0.1 in base 2)
     *     count=2 -> 0.25 (0.01 in base 2)
     *     count=3 -> 0.75 (0.11 in base 2)
     *     count=4 -> 0.125(0.001 in base 2)
     * ```
     *
     * @param[in] count index of the sequence
     * @param[in] base base of the sequence
     * @return double
     */
    constexpr auto vdc(size_t count, const size_t base) -> double {
        auto reslt = 0.0;
        auto denom = 1.0;
        auto temp_count = count;
        while (temp_count != 0) {
            const auto remainder = temp_count % base;
            temp_count /= base;
            denom *= double(base);
            reslt += double(remainder) / denom;
        }
        return reslt;
    }

    /**
     * @brief Van der Corput sequence generator
     *
     * `VdCorput` is a class that generates the Van der Corput sequence. The Van der
     * Corput sequence is a low-discrepancy sequence that is commonly used in
     * quasi-Monte Carlo methods. The sequence is generated by iterating over a base
     * and calculating the fractional part of the number in that base. The
     * `VdCorput` class keeps track of the current count and base, and provides a
     * `pop()` method that returns the next value in the sequence.
     *
     * ```svgbob
     *     VdCorput(2) sequence:
     *     pop() -> 0.5   (0.1 base 2)
     *     pop() -> 0.25  (0.01 base 2)
     *     pop() -> 0.75  (0.11 base 2)
     *     pop() -> 0.125 (0.001 base 2)
     *     ...
     * ```
     */
    class VdCorput {
        std::atomic<size_t> count;
        size_t base;
        std::array<double, MAX_REVERSE_BITS> rev_lst;

      public:
        /**
         * @brief Construct a new VdCorput object
         *
         * The `VdCorput(size_t base)` constructor is initializing a `VdCorput`
         * object with a given base. The base is used to generate the Van der Corput
         * sequence.
         *
         * @param[in] base the base of the Van der Corput sequence
         */
        explicit VdCorput(const size_t base) : count{0}, base{base}, rev_lst{} {
            double reverse = 1.0;
            for (size_t i = 0; i < MAX_REVERSE_BITS; ++i) {
                reverse /= double(base);
                this->rev_lst[i] = reverse;
            }
        }

        /**
         * @brief pop
         *
         * The `auto pop() -> double` function is a member function of the
         * `VdCorput` class. It returns a `double` value. This function is used to
         * generate the next value in the Van der Corput sequence. It increments the
         * count and calculates the Van der Corput sequence value for that count and
         * base.
         *
         * @return double
         */
        auto pop() -> double {
            size_t count_value = this->count.fetch_add(1, std::memory_order_relaxed) + 1;  // ignore 0
            size_t idx = 0;
            double res = 0.0;
            while (count_value != 0) {
                const auto remainder = count_value % this->base;
                count_value /= this->base;
                res += this->rev_lst[idx] * double(remainder);
                ++idx;
            }
            return res;
        }

        /**
         * @brief reseed
         *
         * The `reseed(size_t seed)` function is used to reset the state of the
         * sequence generator to a specific seed value. This allows the sequence
         * generator to start generating the sequence from the beginning, or from a
         * specific point in the sequence, depending on the value of the seed.
         *
         * @param[in] seed the seed value to reset the sequence generator to
         */
        auto reseed(const size_t seed) -> void { this->count.store(seed, std::memory_order_relaxed); }

        /**
         * @brief Move constructor
         */
        VdCorput(VdCorput&& other) noexcept 
            : count(other.count.load()), base(other.base), rev_lst(other.rev_lst) {}

        /**
         * @brief Move assignment operator
         */
        VdCorput& operator=(VdCorput&& other) noexcept {
            if (this != &other) {
                count.store(other.count.load());
                base = other.base;
                rev_lst = other.rev_lst;
            }
            return *this;
        }
    };

    /**
     * @brief Halton sequence generator
     *
     * The `Halton` class is a sequence generator that generates points in a
     * 2-dimensional space using the Halton sequence. The Halton sequence is a
     * low-discrepancy sequence that is commonly used in quasi-Monte Carlo methods.
     * It is generated by iterating over two different bases and calculating the
     * fractional parts of the numbers in those bases. The `Halton` class keeps
     * track of the current count and bases, and provides a `pop()` method that
     * returns the next point in the sequence as a `std::array<double, 2>`.
     *
     * ```svgbob
     *     Halton(2,3) sequence:
     *     pop() -> (0.5, 0.333)  (VdC(2) -> 0.5, VdC(3) -> 0.333)
     *     pop() -> (0.25, 0.666) (VdC(2) -> 0.25, VdC(3) -> 0.666)
     *     pop() -> (0.75, 0.111) (VdC(2) -> 0.75, VdC(3) -> 0.111)
     *     ...
     * ```
     */
    class Halton {
        VdCorput vdc0;
        VdCorput vdc1;

      public:
        /**
         * @brief Construct a new Halton object
         *
         * The `Halton(const size_t base0, const size_t base1)` is a constructor for
         * the `Halton` class. It takes two parameters `base0` and `base1`, which
         * are used as the bases for generating the Halton sequence. The
         * `constexpr` keyword indicates that the constructor is constexpr,
         * meaning it can be evaluated at compile-time if possible.
         *
         * @param[in] base0
         * @param[in] base1
         */
        Halton(const size_t base0, const size_t base1) : vdc0(base0), vdc1(base1) {}

        /**
         * @brief pop
         *
         * The `pop()` function is used to generate the next value in the sequence.
         * For example, in the `VdCorput` class, `pop()` increments the count and
         * calculates the Van der Corput sequence value for that count and base. In
         * the `Halton` class, `pop()` returns the next point in the Halton sequence
         * as a `std::array<double, 2>`. Similarly, in the `Circle` class, `pop()`
         * returns the next point on the unit circle as a `std::array<double, 2>`.
         * In the `Sphere` class, `pop()` returns the next point on the unit sphere
         * as a `std::array<double, 3>`. And in the `Sphere3Hopf` class, `pop()`
         * returns the next point on the 3-sphere using the Hopf fibration as a
         * `std::array<double, 4>`.
         *
         * @return std::array<double, 2>
         */
        auto pop() -> std::array<double, 2> {  //
            return {this->vdc0.pop(), this->vdc1.pop()};
        }

        /**
         * @brief reseed
         *
         * The `reseed(size_t seed)` function is used to reset the state of the
         * sequence generator to a specific seed value. This allows the sequence
         * generator to start generating the sequence from the beginning, or from a
         * specific point in the sequence, depending on the value of the seed.
         *
         * @param[in] seed
         */
        auto reseed(const size_t seed) -> void {
            this->vdc0.reseed(seed);
            this->vdc1.reseed(seed);
        }
    };

    /**
     * @brief Circle sequence generator
     *
     * The `Circle` class is a sequence generator that generates points on a unit
     * circle using the Van der Corput sequence. It uses the `VdCorput` class to
     * generate the sequence values and maps them to points on the unit circle. The
     * `pop()` method returns the next point on the unit circle as a
     * `std::array<double, 2>`, where the first element represents the x-coordinate
     * and the second element represents the y-coordinate of the point. The
     * `reseed()` method is used to reset the state of the sequence generator to a
     * specific seed value.
     *
     * ```svgbob
     *     Unit Circle:
     *         (0,1)
     *           *
     *    (-1,0) *   * (1,0)
     *           *
     *        (0,-1)
     *
     *     Points distributed more evenly
     *     than random sampling
     * ```
     */
    class Circle {
        VdCorput vdc;

      public:
        /**
         * @brief Construct a new Circle object
         *
         * The `Circle(size_t base)` constructor is initializing a `Circle` object
         * with a given base. The base is used to generate the Van der Corput
         * sequence, which is then mapped to points on the unit circle. The
         * `explicit` keyword indicates that this constructor can only be used for
         * explicit construction and not for implicit conversions.
         *
         * @param[in] base
         */
        explicit Circle(const size_t base) : vdc(base) {}

        /**
         * @brief pop
         *
         * The `pop()` function is used to generate the next value in the sequence.
         * In the `VdCorput` class, `pop()` increments the count and calculates the
         * Van der Corput sequence value for that count and base. In the `Halton`
         * class, `pop()` returns the next point in the Halton sequence as a
         * `std::array<double, 2>`. Similarly, in the `Circle` class, `pop()`
         * returns the next point on the unit circle as a `std::array<double, 2>`.
         * In the `Sphere` class, `pop()` returns the next point on the unit sphere
         * as a `std::array<double, 3>`. And in the `Sphere3Hopf` class, `pop()`
         * returns the next point on the 3-sphere using the Hopf fibration as a
         * `std::array<double, 4>`.
         *
         * @return std::array<double, 2>
         */
        auto pop() -> std::array<double, 2> {
            auto theta = this->vdc.pop() * TWO_PI;  // map to [0, 2*pi];
            return {std::cos(theta), std::sin(theta)};
        }

        /**
         * @brief reseed
         *
         * The `reseed(size_t seed)` function is used to reset the state of the
         * sequence generator to a specific seed value. This allows the sequence
         * generator to start generating the sequence from the beginning, or from a
         * specific point in the sequence, depending on the value of the seed.
         *
         * @param[in] seed
         */
        auto reseed(const size_t seed) -> void { this->vdc.reseed(seed); }
    };

    /**
     * @brief Disk sequence generator
     *
     * The `Disk` class is a sequence generator that generates points in a
     * 2-dimensional space using the Disk sequence. The Disk sequence is a
     * low-discrepancy sequence that is commonly used in quasi-Monte Carlo methods.
     * It is generated by iterating over two different bases and calculating the
     * fractional parts of the numbers in those bases. The `Disk` class keeps
     * track of the current count and bases, and provides a `pop()` method that
     * returns the next point in the sequence as a `std::array<double, 2>`.
     *
     * ```svgbob
     *     Unit Disk:
     *         *****
     *      ***     ***
     *    **         **
     *   *             *
     *   *             *  More evenly
     *   *             *  distributed
     *    **         **   than random
     *      ***     ***
     *         *****
     * ```
     */
    class Disk {
        VdCorput vdc0;
        VdCorput vdc1;

      public:
        /**
         * @brief Construct a new Disk object
         *
         * The `Disk(const size_t base0, const size_t base1)` is a constructor for
         * the `Disk` class. It takes two parameters `base0` and `base1`, which
         * are used as the bases for generating the Disk sequence. The
         * `constexpr` keyword indicates that the constructor is constexpr,
         * meaning it can be evaluated at compile-time if possible.
         *
         * @param[in] base0
         * @param[in] base1
         */
        Disk(const size_t base0, const size_t base1) : vdc0(base0), vdc1(base1) {}

        /**
         * @brief pop
         *
         * The `pop()` function is used to generate the next value in the sequence.
         * For example, in the `VdCorput` class, `pop()` increments the count and
         * calculates the Van der Corput sequence value for that count and base. In
         * the `Disk` class, `pop()` returns the next point in the Disk sequence
         * as a `std::array<double, 2>`. Similarly, in the `Circle` class, `pop()`
         * returns the next point on the unit circle as a `std::array<double, 2>`.
         * In the `Sphere` class, `pop()` returns the next point on the unit sphere
         * as a `std::array<double, 3>`. And in the `Sphere3Hopf` class, `pop()`
         * returns the next point on the 3-sphere using the Hopf fibration as a
         * `std::array<double, 4>`.
         *
         * @return std::array<double, 2>
         */
        auto pop() -> std::array<double, 2> {  //
            auto theta = this->vdc0.pop() * TWO_PI;   // map to [0, 2*pi];
            auto radius = std::sqrt(this->vdc1.pop());
            return {radius * std::cos(theta), radius * std::sin(theta)};
        }

        /**
         * @brief reseed
         *
         * The `reseed(size_t seed)` function is used to reset the state of the
         * sequence generator to a specific seed value. This allows the sequence
         * generator to start generating the sequence from the beginning, or from a
         * specific point in the sequence, depending on the value of the seed.
         *
         * @param[in] seed
         */
        auto reseed(const size_t seed) -> void {
            this->vdc0.reseed(seed);
            this->vdc1.reseed(seed);
        }
    };

    /**
     * @brief Sphere sequence generator
     *
     * The `Sphere` class is a sequence generator that generates points on a unit
     * sphere using the Van der Corput sequence. It uses the `VdCorput` class to
     * generate the sequence values and maps them to points on the unit sphere. The
     * `pop()` method returns the next point on the unit sphere as a
     * `std::array<double, 3>`, where the first element represents the x-coordinate,
     * the second element represents the y-coordinate of the point, and the third
     * element represents the z-coordinate of the point. The
     * `reseed()` method is used to reset the state of the sequence generator to a
     * specific seed value.
     *
     * ```svgbob
     *     Unit Sphere:
     *          *****
     *       **       **
     *     **           **
     *    *               *
     *    *      O        *  Points distributed
     *    *               *  evenly on surface
     *     **           **
     *       **       **
     *          *****
     * ```
     */
    class Sphere {
        VdCorput vdcgen;
        Circle cirgen;

      public:
        /**
         * @brief Construct a new Sphere object
         *
         * @param[in] base0
         * @param[in] base1
         */
        Sphere(const size_t base0, const size_t base1) : vdcgen(base0), cirgen(base1) {}

        /**
         * @brief pop
         *
         * The `pop()` function is used to generate the next value in the sequence.
         * In the `VdCorput` class, `pop()` increments the count and calculates the
         * Van der Corput sequence value for that count and base. In the `Disk`
         * class, `pop()` returns the next point in the Disk sequence as a
         * `std::array<double, 2>`. Similarly, in the `Circle` class, `pop()`
         * returns the next point on the unit circle as a `std::array<double, 2>`.
         * In the `Sphere` class, `pop()` returns the next point on the unit sphere
         * as a `std::array<double, 3>`. And in the `Sphere3Hopf` class, `pop()`
         * returns the next point on the 3-sphere using the Hopf fibration as a
         * `std::array<double, 4>`.
         *
         * @return std::array<double, 3>
         */
        auto pop() -> std::array<double, 3> {
            auto cosphi = (MAPPING_FACTOR * this->vdcgen.pop()) - 1.0;  // map to [-1, 1];
            auto sinphi = std::sqrt(1.0 - (cosphi * cosphi));
            auto arr = this->cirgen.pop();
            return {sinphi * arr[0], sinphi * arr[1], cosphi};
        }

        /**
         * @brief reseed
         *
         * The `reseed(size_t seed)` function is used to reset the state of the
         * sequence generator to a specific seed value. This allows the sequence
         * generator to start generating the sequence from the beginning, or from a
         * specific point in the sequence, depending on the value of the seed.
         *
         * @param[in] seed
         */
        auto reseed(const size_t seed) -> void {
            this->cirgen.reseed(seed);
            this->vdcgen.reseed(seed);
        }
    };

    /**
     * @brief S(3) sequence generator by Hopf fibration
     *
     * The `Sphere3Hopf` class is a sequence generator that generates points on a
     * 3-sphere using the Hopf fibration. It uses three instances of the `VdCorput`
     * class to generate the sequence values and maps them to points on the
     * 3-sphere. The `pop()` method returns the next point on the 3-sphere as a
     * `std::array<double, 4>`, where the first three elements represent the x, y,
     * and z coordinates of the point, and the fourth element represents the w
     * coordinate. The `reseed()` method is used to reset the state of the sequence
     * generator to a specific seed value.
     *
     * ```svgbob
     *     3-Sphere (S3) visualization:
     *     A 4D hypersphere where points (x,y,z,w)
     *     satisfy x²+y²+z²+w² = 1
     *
     *         4D hypersurface
     *            _____
     *         .-'     '-.
     *       ,'           ',
     *      /               \
     *     |        O        |  (4D analog of sphere)
     *      \               /
     *       '.           .'
     *         '-.....-'
     * ```
     */
    class Sphere3Hopf {
        VdCorput vdc0;
        VdCorput vdc1;
        VdCorput vdc2;

      public:
        /**
         * @brief Construct a new Sphere 3 Hopf object
         *
         * @param[in] base0
         * @param[in] base1
         * @param[in] base2
         */
        Sphere3Hopf(const size_t base0, const size_t base1, const size_t base2)
            : vdc0(base0), vdc1(base1), vdc2(base2) {}

        /**
         * @brief pop
         *
         * The `pop()` function is used to generate the next value in the sequence.
         * In the `VdCorput` class, `pop()` increments the count and calculates the
         * Van der Corput sequence value for that count and base. In the `Disk`
         * class, `pop()` returns the next point in the Disk sequence as a
         * `std::array<double, 2>`. Similarly, in the `Circle` class, `pop()`
         * returns the next point on the unit circle as a `std::array<double, 2>`.
         * In the `Sphere` class, `pop()` returns the next point on the unit sphere
         * as a `std::array<double, 3>`. And in the `Sphere3Hopf` class, `pop()`
         * returns the next point on the 3-sphere using the Hopf fibration as a
         * `std::array<double, 4>`.
         *
         * @return std::array<double, 4>
         */
        auto pop() -> std::array<double, 4> {
            auto phi = this->vdc0.pop() * TWO_PI;  // map to [0, 2*pi];
            auto psy = this->vdc1.pop() * TWO_PI;  // map to [0, 2*pi];
            auto vdc = this->vdc2.pop();
            auto cos_eta = std::sqrt(vdc);
            auto sin_eta = std::sqrt(1.0 - vdc);
            return {
                cos_eta * std::cos(psy),
                cos_eta * std::sin(psy),
                sin_eta * std::cos(phi + psy),
                sin_eta * std::sin(phi + psy),
            };
        }

        /**
         * @brief reseed
         *
         * The `reseed(size_t seed)` function is used to reset the state of the
         * sequence generator to a specific seed value. This allows the sequence
         * generator to start generating the sequence from the beginning, or from a
         * specific point in the sequence, depending on the value of the seed.
         *
         * @param[in] seed
         */
        auto reseed(size_t seed) -> void {
            this->vdc0.reseed(seed);
            this->vdc1.reseed(seed);
            this->vdc2.reseed(seed);
        }
    };

    extern size_t dummy(size_t index);
}  // namespace ldsgen
