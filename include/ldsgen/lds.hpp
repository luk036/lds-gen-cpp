#pragma once

#include <array>
#include <atomic>
#include <cmath>
#include <cstddef>
#include <iterator>
#include <limits>
#include <vector>

#ifndef M_PI
#    define M_PI 3.14159265358979323846264338327950288
#endif

namespace ldsgen {

    constexpr const auto TWO_PI = 2.0 * M_PI;

    // Constants for magic numbers
    constexpr size_t MAX_REVERSE_BITS = 64;
    constexpr double MAPPING_FACTOR = 2.0;

    /**
     * @brief Forward iterator for sequence generators
     *
     * Provides STL-compatible iterator interface for all generators.
     * Allows use in range-based for loops and STL algorithms.
     *
     * ```cpp
     * VdCorput gen(2);
     * std::vector<double> points(gen.begin(), gen.begin() + 100);
     * ```
     *
     * @tparam Generator The generator class
     * @tparam Value The value type (double or array)
     */
    template<typename Generator, typename Value>
    class GeneratorIterator {
        Generator* gen;
        size_t index;

      public:
        using iterator_category = std::input_iterator_tag;
        using value_type = Value;
        using difference_type = std::ptrdiff_t;
        using pointer = const value_type*;
        using reference = value_type;

        explicit GeneratorIterator(Generator* g = nullptr, size_t idx = 0)
            : gen{g}, index{idx} {}

        /**
         * @brief Dereference operator
         */
        auto operator*() const -> Value {
            if (gen) {
                auto temp_idx = gen->get_index();
                gen->reseed(index);
                auto value = gen->pop();
                gen->reseed(temp_idx);
                return value;
            }
            return Value{};
        }

        /**
         * @brief Pre-increment operator
         */
        auto operator++() -> GeneratorIterator& {
            ++index;
            return *this;
        }

        /**
         * @brief Post-increment operator
         */
        auto operator++(int) -> GeneratorIterator {
            auto temp = *this;
            ++index;
            return temp;
        }

        /**
         * @brief Equality comparison
         */
        auto operator==(const GeneratorIterator& other) const -> bool {
            return index == other.index;
        }

        /**
         * @brief Inequality comparison
         */
        auto operator!=(const GeneratorIterator& other) const -> bool {
            return index != other.index;
        }

        /**
         * @brief Get current index
         */
        [[nodiscard]] auto get_index() const -> size_t { return index; }
    };

    /**
     * @brief Van der Corput sequence
     *
     * The `vdc` function is calculating the Van der Corput sequence value for a
     * given index `count` and base `base`. It returns a `double` value.
     *
     * ```svgbob
     *     Base 2 Example:
     *     count=1 -> 0.5  (0.1 in base 2)
     *     count=2 -> 0.25 (0.01 in base 2)
     *     count=3 -> 0.75 (0.11 in base 2)
     *     count=4 -> 0.125(0.001 in base 2)
     * ```
     *
     * @param[in] count index of the sequence
     * @param[in] base base of the sequence
     * @return double
     */
    constexpr auto vdc(size_t count, const size_t base) -> double {
        auto reslt = 0.0;
        auto denom = 1.0;
        auto temp_count = count;
        while (temp_count != 0) {
            const auto remainder = temp_count % base;
            temp_count /= base;
            denom *= double(base);
            reslt += double(remainder) / denom;
        }
        return reslt;
    }

    /**
     * @brief Van der Corput sequence generator
     *
     * `VdCorput` is a class that generates the Van der Corput sequence. The Van der
     * Corput sequence is a low-discrepancy sequence that is commonly used in
     * quasi-Monte Carlo methods. The sequence is generated by iterating over a base
     * and calculating the fractional part of the number in that base. The
     * `VdCorput` class keeps track of the current count and base, and provides a
     * `pop()` method that returns the next value in the sequence.
     *
     * ```svgbob
     *     VdCorput(2) sequence:
     *     pop() -> 0.5   (0.1 base 2)
     *     pop() -> 0.25  (0.01 base 2)
     *     pop() -> 0.75  (0.11 base 2)
     *     pop() -> 0.125 (0.001 base 2)
     *     ...
     * ```
     */
    class VdCorput {
        std::atomic<size_t> count;
        size_t base;
        std::array<double, MAX_REVERSE_BITS> rev_lst;

      public:
        /**
         * @brief Construct a new VdCorput object
         *
         * The `VdCorput(size_t base)` constructor is initializing a `VdCorput`
         * object with a given base. The base is used to generate the Van der Corput
         * sequence.
         *
         * @param[in] base the base of the Van der Corput sequence
         */
        explicit VdCorput(const size_t base) : count{0}, base{base}, rev_lst{} {
            double reverse = 1.0;
            for (size_t i = 0; i < MAX_REVERSE_BITS; ++i) {
                reverse /= double(base);
                this->rev_lst[i] = reverse;
            }
        }

        /**
         * @brief pop
         *
         * The `auto pop() -> double` function is a member function of the
         * `VdCorput` class. It returns a `double` value. This function is used to
         * generate the next value in the Van der Corput sequence. It increments the
         * count and calculates the Van der Corput sequence value for that count and
         * base.
         *
         * @return double
         */
        auto pop() -> double {
            size_t count_value = this->count.fetch_add(1, std::memory_order_relaxed) + 1;  // ignore 0
            size_t idx = 0;
            double res = 0.0;
            while (count_value != 0) {
                const auto remainder = count_value % this->base;
                count_value /= this->base;
                res += this->rev_lst[idx] * double(remainder);
                ++idx;
            }
            return res;
        }

        /**
         * @brief Peek at the next value without advancing state
         *
         * @return double the next value in the sequence
         */
        [[nodiscard]] auto peek() -> double {
            size_t count_value = this->count.load(std::memory_order_relaxed) + 1;
            size_t idx = 0;
            double res = 0.0;
            while (count_value != 0) {
                const auto remainder = count_value % this->base;
                count_value /= this->base;
                res += this->rev_lst[idx] * double(remainder);
                ++idx;
            }
            return res;
        }

        /**
         * @brief Generate multiple values efficiently
         *
         * @param[in] n number of values to generate
         * @return std::vector<double> vector of values
         */
        [[nodiscard]] auto batch(size_t n) -> std::vector<double> {
            std::vector<double> result;
            result.reserve(n);
            for (size_t i = 0; i < n; ++i) {
                result.push_back(this->pop());
            }
            return result;
        }

        /**
         * @brief Skip n values in the sequence
         *
         * @param[in] n number of values to skip
         */
        auto skip(size_t n) -> void {
            this->count.fetch_add(n, std::memory_order_relaxed);
        }

        /**
         * @brief reseed
         *
         * The `reseed(size_t seed)` function is used to reset the state of the
         * sequence generator to a specific seed value. This allows the sequence
         * generator to start generating the sequence from the beginning, or from a
         * specific point in the sequence, depending on the value of the seed.
         *
         * @param[in] seed the seed value to reset the sequence generator to
         */
        auto reseed(const size_t seed) -> void {
            this->count.store(seed, std::memory_order_relaxed);
        }

        /**
         * @brief Get current index
         *
         * @return size_t current index in the sequence
         */
        [[nodiscard]] auto get_index() const -> size_t {
            return this->count.load(std::memory_order_relaxed);
        }

        /**
         * @brief Get iterator to beginning
         *
         * @return GeneratorIterator<VdCorput, double>
         */
        auto begin() -> GeneratorIterator<VdCorput, double> {
            return GeneratorIterator<VdCorput, double>(this);
        }

        /**
         * @brief Get iterator to end (infinite sequence)
         *
         * For infinite sequences, you typically use begin() + n to get a specific position
         *
         * @return GeneratorIterator<VdCorput, double>
         */
        [[nodiscard]] auto end() const -> GeneratorIterator<VdCorput, double> {
            return GeneratorIterator<VdCorput, double>(nullptr, std::numeric_limits<size_t>::max());
        }

        VdCorput(VdCorput&&) noexcept = delete;
        VdCorput& operator=(VdCorput&&) noexcept = delete;
    };

    /**
     * @brief Halton sequence generator
     *
     * The `Halton` class is a sequence generator that generates points in a
     * 2-dimensional space using the Halton sequence. The Halton sequence is a
     * low-discrepancy sequence that is commonly used in quasi-Monte Carlo methods.
     * It is generated by iterating over two different bases and calculating the
     * fractional parts of the numbers in those bases. The `Halton` class keeps
     * track of the current count and bases, and provides a `pop()` method that
     * returns the next point in the sequence as a `std::array<double, 2>`.
     *
     * ```svgbob
     *     Halton(2,3) sequence:
     *     pop() -> (0.5, 0.333)  (VdC(2) -> 0.5, VdC(3) -> 0.333)
     *     pop() -> (0.25, 0.666) (VdC(2) -> 0.25, VdC(3) -> 0.666)
     *     pop() -> (0.75, 0.111) (VdC(2) -> 0.75, VdC(3) -> 0.111)
     *     ...
     * ```
     */
    class Halton {
        VdCorput vdc0;
        VdCorput vdc1;

      public:
        /**
         * @brief Construct a new Halton object
         *
         * The `Halton(const size_t base0, const size_t base1)` is a constructor for
         * the `Halton` class. It takes two parameters `base0` and `base1`, which
         * are used as the bases for generating the Halton sequence. The
         * `constexpr` keyword indicates that the constructor is constexpr,
         * meaning it can be evaluated at compile-time if possible.
         *
         * @param[in] base0
         * @param[in] base1
         */
        Halton(const size_t base0, const size_t base1) : vdc0(base0), vdc1(base1) {}

        /**
         * @brief pop
         *
         * The `pop()` function is used to generate the next value in the sequence.
         * For example, in the `VdCorput` class, `pop()` increments the count and
         * calculates the Van der Corput sequence value for that count and base. In
         * the `Halton` class, `pop()` returns the next point in the Halton sequence
         * as a `std::array<double, 2>`. Similarly, in the `Circle` class, `pop()`
         * returns the next point on the unit circle as a `std::array<double, 2>`.
         * In the `Sphere` class, `pop()` returns the next point on the unit sphere
         * as a `std::array<double, 3>`. And in the `Sphere3Hopf` class, `pop()`
         * returns the next point on the 3-sphere using the Hopf fibration as a
         * `std::array<double, 4>`.
         *
         * @return std::array<double, 2>
         */
        auto pop() -> std::array<double, 2> {  //
            return {this->vdc0.pop(), this->vdc1.pop()};
        }

        /**
         * @brief Peek at the next value without advancing state
         *
         * @return std::array<double, 2> the next point in the sequence
         */
        [[nodiscard]] auto peek() -> std::array<double, 2> {
            return {this->vdc0.peek(), this->vdc1.peek()};
        }

        /**
         * @brief Generate multiple values efficiently
         *
         * @param[in] n number of values to generate
         * @return std::vector<std::array<double, 2>> vector of points
         */
        [[nodiscard]] auto batch(size_t n) -> std::vector<std::array<double, 2>> {
            std::vector<std::array<double, 2>> result;
            result.reserve(n);
            for (size_t i = 0; i < n; ++i) {
                result.push_back(this->pop());
            }
            return result;
        }

        /**
         * @brief Skip n values in the sequence
         *
         * @param[in] n number of values to skip
         */
        auto skip(size_t n) -> void {
            this->vdc0.skip(n);
            this->vdc1.skip(n);
        }

        /**
         * @brief reseed
         *
         * The `reseed(size_t seed)` function is used to reset the state of the
         * sequence generator to a specific seed value. This allows the sequence
         * generator to start generating the sequence from the beginning, or from a
         * specific point in the sequence, depending on the value of the seed.
         *
         * @param[in] seed
         */
        auto reseed(const size_t seed) -> void {
            this->vdc0.reseed(seed);
            this->vdc1.reseed(seed);
        }

        /**
         * @brief Get current index
         *
         * @return size_t current index in the sequence
         */
        [[nodiscard]] auto get_index() const -> size_t {
            return this->vdc0.get_index();
        }

        /**
         * @brief Get iterator to beginning
         *
         * @return GeneratorIterator<Halton, std::array<double, 2>>
         */
        auto begin() -> GeneratorIterator<Halton, std::array<double, 2>> {
            return GeneratorIterator<Halton, std::array<double, 2>>(this);
        }

        /**
         * @brief Get iterator to end (infinite sequence)
         *
         * @return GeneratorIterator<Halton, std::array<double, 2>>
         */
        [[nodiscard]] auto end() const -> GeneratorIterator<Halton, std::array<double, 2>> {
            return GeneratorIterator<Halton, std::array<double, 2>>(nullptr,
                                                                   std::numeric_limits<size_t>::max());
        }
    };

    /**
     * @brief Circle sequence generator
     *
     * The `Circle` class is a sequence generator that generates points on a unit
     * circle using the Van der Corput sequence. It uses the `VdCorput` class to
     * generate the sequence values and maps them to points on the unit circle. The
     * `pop()` method returns the next point on the unit circle as a
     * `std::array<double, 2>`, where the first element represents the x-coordinate
     * and the second element represents the y-coordinate of the point. The
     * `reseed()` method is used to reset the state of the sequence generator to a
     * specific seed value.
     *
     * ```svgbob
     *     Unit Circle:
     *         (0,1)
     *           *
     *    (-1,0) *   * (1,0)
     *           *
     *        (0,-1)
     *
     *     Points distributed more evenly
     *     than random sampling
     * ```
     */
    class Circle {
        VdCorput vdc;

      public:
        /**
         * @brief Construct a new Circle object
         *
         * The `Circle(size_t base)` constructor is initializing a `Circle` object
         * with a given base. The base is used to generate the Van der Corput
         * sequence, which is then mapped to points on the unit circle. The
         * `explicit` keyword indicates that this constructor can only be used for
         * explicit construction and not for implicit conversions.
         *
         * @param[in] base
         */
        explicit Circle(const size_t base) : vdc(base) {}

        /**
         * @brief pop
         *
         * The `pop()` function is used to generate the next value in the sequence.
         * In the `VdCorput` class, `pop()` increments the count and calculates the
         * Van der Corput sequence value for that count and base. In the `Halton`
         * class, `pop()` returns the next point in the Halton sequence as a
         * `std::array<double, 2>`. Similarly, in the `Circle` class, `pop()`
         * returns the next point on the unit circle as a `std::array<double, 2>`.
         * In the `Sphere` class, `pop()` returns the next point on the unit sphere
         * as a `std::array<double, 3>`. And in the `Sphere3Hopf` class, `pop()`
         * returns the next point on the 3-sphere using the Hopf fibration as a
         * `std::array<double, 4>`.
         *
         * @return std::array<double, 2>
         */
        auto pop() -> std::array<double, 2> {
            auto theta = this->vdc.pop() * TWO_PI;  // map to [0, 2*pi];
            return {std::cos(theta), std::sin(theta)};
        }

        /**
         * @brief Peek at the next value without advancing state
         *
         * @return std::array<double, 2> next point on the circle
         */
        [[nodiscard]] auto peek() -> std::array<double, 2> {
            auto theta = this->vdc.peek() * TWO_PI;  // map to [0, 2*pi];
            return {std::cos(theta), std::sin(theta)};
        }

        /**
         * @brief Generate multiple values efficiently
         *
         * @param[in] n number of values to generate
         * @return std::vector<std::array<double, 2>> vector of points
         */
        [[nodiscard]] auto batch(size_t n) -> std::vector<std::array<double, 2>> {
            std::vector<std::array<double, 2>> result;
            result.reserve(n);
            for (size_t i = 0; i < n; ++i) {
                result.push_back(this->pop());
            }
            return result;
        }

        /**
         * @brief Skip n values in the sequence
         *
         * @param[in] n number of values to skip
         */
        auto skip(size_t n) -> void { this->vdc.skip(n); }

        /**
         * @brief reseed
         *
         * The `reseed(size_t seed)` function is used to reset the state of the
         * sequence generator to a specific seed value. This allows the sequence
         * generator to start generating the sequence from the beginning, or from a
         * specific point in the sequence, depending on the value of the seed.
         *
         * @param[in] seed
         */
        auto reseed(const size_t seed) -> void { this->vdc.reseed(seed); }

        /**
         * @brief Get current index
         *
         * @return size_t current index in sequence
         */
        [[nodiscard]] auto get_index() const -> size_t {
            return this->vdc.get_index();
        }

        /**
         * @brief Get iterator to beginning
         *
         * @return GeneratorIterator<Circle, std::array<double, 2>>
         */
        auto begin() -> GeneratorIterator<Circle, std::array<double, 2>> {
            return GeneratorIterator<Circle, std::array<double, 2>>(this);
        }

        /**
         * @brief Get iterator to end (infinite sequence)
         *
         * @return GeneratorIterator<Circle, std::array<double, 2>>
         */
        [[nodiscard]] auto end() const -> GeneratorIterator<Circle, std::array<double, 2>> {
            return GeneratorIterator<Circle, std::array<double, 2>>(nullptr,
                                                                   std::numeric_limits<size_t>::max());
        }
    };

    /**
     * @brief Disk sequence generator
     *
     * The `Disk` class is a sequence generator that generates points in a
     * 2-dimensional space using the Disk sequence. The Disk sequence is a
     * low-discrepancy sequence that is commonly used in quasi-Monte Carlo methods.
     * It is generated by iterating over two different bases and calculating the
     * fractional parts of the numbers in those bases. The `Disk` class keeps
     * track of the current count and bases, and provides a `pop()` method that
     * returns the next point in the sequence as a `std::array<double, 2>`.
     *
     * ```svgbob
     *     Unit Disk:
     *         *****
     *      ***     ***
     *    **         **
     *   *             *
     *   *             *  More evenly
     *   *             *  distributed
     *    **         **   than random
     *      ***     ***
     *         *****
     * ```
     */
    class Disk {
        VdCorput vdc0;
        VdCorput vdc1;

      public:
        /**
         * @brief Construct a new Disk object
         *
         * The `Disk(const size_t base0, const size_t base1)` is a constructor for
         * the `Disk` class. It takes two parameters `base0` and `base1`, which
         * are used as the bases for generating the Disk sequence. The
         * `constexpr` keyword indicates that the constructor is constexpr,
         * meaning it can be evaluated at compile-time if possible.
         *
         * @param[in] base0
         * @param[in] base1
         */
        Disk(const size_t base0, const size_t base1) : vdc0(base0), vdc1(base1) {}

        /**
         * @brief pop
         *
         * The `pop()` function is used to generate the next value in the sequence.
         * For example, in the `VdCorput` class, `pop()` increments the count and
         * calculates the Van der Corput sequence value for that count and base. In
         * the `Disk` class, `pop()` returns the next point in the Disk sequence
         * as a `std::array<double, 2>`. Similarly, in the `Circle` class, `pop()`
         * returns the next point on the unit circle as a `std::array<double, 2>`.
         * In the `Sphere` class, `pop()` returns the next point on the unit sphere
         * as a `std::array<double, 3>`. And in the `Sphere3Hopf` class, `pop()`
         * returns the next point on the 3-sphere using the Hopf fibration as a
         * `std::array<double, 4>`.
         *
         * @return std::array<double, 2>
         */
        auto pop() -> std::array<double, 2> {        //
            auto theta = this->vdc0.pop() * TWO_PI;  // map to [0, 2*pi];
            auto radius = std::sqrt(this->vdc1.pop());
            return {radius * std::cos(theta), radius * std::sin(theta)};
        }

        /**
         * @brief Peek at the next value without advancing state
         *
         * @return std::array<double, 2> next point in the disk
         */
        [[nodiscard]] auto peek() -> std::array<double, 2> {
            auto theta = this->vdc0.peek() * TWO_PI;  // map to [0, 2*pi];
            auto radius = std::sqrt(this->vdc1.peek());
            return {radius * std::cos(theta), radius * std::sin(theta)};
        }

        /**
         * @brief Generate multiple values efficiently
         *
         * @param[in] n number of values to generate
         * @return std::vector<std::array<double, 2>> vector of points
         */
        [[nodiscard]] auto batch(size_t n) -> std::vector<std::array<double, 2>> {
            std::vector<std::array<double, 2>> result;
            result.reserve(n);
            for (size_t i = 0; i < n; ++i) {
                result.push_back(this->pop());
            }
            return result;
        }

        /**
         * @brief Skip n values in the sequence
         *
         * @param[in] n number of values to skip
         */
        auto skip(size_t n) -> void {
            this->vdc0.skip(n);
            this->vdc1.skip(n);
        }

        /**
         * @brief reseed
         *
         * The `reseed(size_t seed)` function is used to reset the state of the
         * sequence generator to a specific seed value. This allows the sequence
         * generator to start generating the sequence from the beginning, or from a
         * specific point in the sequence, depending on the value of the seed.
         *
         * @param[in] seed
         */
        auto reseed(const size_t seed) -> void {
            this->vdc0.reseed(seed);
            this->vdc1.reseed(seed);
        }

        /**
         * @brief Get current index
         *
         * @return size_t current index in sequence
         */
        [[nodiscard]] auto get_index() const -> size_t {
            return this->vdc0.get_index();
        }

        /**
         * @brief Get iterator to beginning
         *
         * @return GeneratorIterator<Disk, std::array<double, 2>>
         */
        auto begin() -> GeneratorIterator<Disk, std::array<double, 2>> {
            return GeneratorIterator<Disk, std::array<double, 2>>(this);
        }

        /**
         * @brief Get iterator to end (infinite sequence)
         *
         * @return GeneratorIterator<Disk, std::array<double, 2>>
         */
        [[nodiscard]] auto end() const -> GeneratorIterator<Disk, std::array<double, 2>> {
            return GeneratorIterator<Disk, std::array<double, 2>>(nullptr,
                                                                   std::numeric_limits<size_t>::max());
        }
    };

    /**
     * @brief Sphere sequence generator
     *
     * The `Sphere` class is a sequence generator that generates points on a unit
     * sphere using the Van der Corput sequence. It uses the `VdCorput` class to
     * generate the sequence values and maps them to points on the unit sphere. The
     * `pop()` method returns the next point on the unit sphere as a
     * `std::array<double, 3>`, where the first element represents the x-coordinate,
     * the second element represents the y-coordinate of the point, and the third
     * element represents the z-coordinate of the point. The
     * `reseed()` method is used to reset the state of the sequence generator to a
     * specific seed value.
     *
     * ```svgbob
     *     Unit Sphere:
     *          *****
     *       **       **
     *     **           **
     *    *               *
     *    *      O        *  Points distributed
     *    *               *  evenly on surface
     *     **           **
     *       **       **
     *          *****
     * ```
     */
    class Sphere {
        VdCorput vdcgen;
        Circle cirgen;

      public:
        /**
         * @brief Construct a new Sphere object
         *
         * @param[in] base0
         * @param[in] base1
         */
        Sphere(const size_t base0, const size_t base1) : vdcgen(base0), cirgen(base1) {}

        /**
         * @brief pop
         *
         * The `pop()` function is used to generate the next value in the sequence.
         * In the `VdCorput` class, `pop()` increments the count and calculates the
         * Van der Corput sequence value for that count and base. In the `Disk`
         * class, `pop()` returns the next point in the Disk sequence as a
         * `std::array<double, 2>`. Similarly, in the `Circle` class, `pop()`
         * returns the next point on the unit circle as a `std::array<double, 2>`.
         * In the `Sphere` class, `pop()` returns the next point on the unit sphere
         * as a `std::array<double, 3>`. And in the `Sphere3Hopf` class, `pop()`
         * returns the next point on the 3-sphere using the Hopf fibration as a
         * `std::array<double, 4>`.
         *
         * @return std::array<double, 3>
         */
        auto pop() -> std::array<double, 3> {
            auto cosphi = (MAPPING_FACTOR * this->vdcgen.pop()) - 1.0;  // map to [-1, 1];
            auto sinphi = std::sqrt(1.0 - (cosphi * cosphi));
            auto arr = this->cirgen.pop();
            return {sinphi * arr[0], sinphi * arr[1], cosphi};
        }

        /**
         * @brief Peek at the next value without advancing state
         *
         * @return std::array<double, 3> next point on the sphere
         */
        [[nodiscard]] auto peek() -> std::array<double, 3> {
            auto cosphi = (MAPPING_FACTOR * this->vdcgen.peek()) - 1.0;  // map to [-1, 1];
            auto sinphi = std::sqrt(1.0 - (cosphi * cosphi));
            auto arr = this->cirgen.peek();
            return {sinphi * arr[0], sinphi * arr[1], cosphi};
        }

        /**
         * @brief Generate multiple values efficiently
         *
         * @param[in] n number of values to generate
         * @return std::vector<std::array<double, 3>> vector of points
         */
        [[nodiscard]] auto batch(size_t n) -> std::vector<std::array<double, 3>> {
            std::vector<std::array<double, 3>> result;
            result.reserve(n);
            for (size_t i = 0; i < n; ++i) {
                result.push_back(this->pop());
            }
            return result;
        }

        /**
         * @brief Skip n values in the sequence
         *
         * @param[in] n number of values to skip
         */
        auto skip(size_t n) -> void {
            this->vdcgen.skip(n);
            this->cirgen.skip(n);
        }

        /**
         * @brief reseed
         *
         * The `reseed(size_t seed)` function is used to reset the state of the
         * sequence generator to a specific seed value. This allows the sequence
         * generator to start generating the sequence from the beginning, or from a
         * specific point in the sequence, depending on the value of the seed.
         *
         * @param[in] seed
         */
        auto reseed(const size_t seed) -> void {
            this->cirgen.reseed(seed);
            this->vdcgen.reseed(seed);
        }

        /**
         * @brief Get current index
         *
         * @return size_t current index in sequence
         */
        [[nodiscard]] auto get_index() const -> size_t {
            return this->vdcgen.get_index();
        }

        /**
         * @brief Get iterator to beginning
         *
         * @return GeneratorIterator<Sphere, std::array<double, 3>>
         */
        auto begin() -> GeneratorIterator<Sphere, std::array<double, 3>> {
            return GeneratorIterator<Sphere, std::array<double, 3>>(this);
        }

        /**
         * @brief Get iterator to end (infinite sequence)
         *
         * @return GeneratorIterator<Sphere, std::array<double, 3>>
         */
        [[nodiscard]] auto end() const -> GeneratorIterator<Sphere, std::array<double, 3>> {
            return GeneratorIterator<Sphere, std::array<double, 3>>(nullptr,
                                                                    std::numeric_limits<size_t>::max());
        }
    };

    /**
     * @brief S(3) sequence generator by Hopf fibration
     *
     * The `Sphere3Hopf` class is a sequence generator that generates points on a
     * 3-sphere using the Hopf fibration. It uses three instances of the `VdCorput`
     * class to generate the sequence values and maps them to points on the
     * 3-sphere. The `pop()` method returns the next point on the 3-sphere as a
     * `std::array<double, 4>`, where the first three elements represent the x, y,
     * and z coordinates of the point, and the fourth element represents the w
     * coordinate. The `reseed()` method is used to reset the state of the sequence
     * generator to a specific seed value.
     *
     * ```svgbob
     *     3-Sphere (S3) visualization:
     *     A 4D hypersphere where points (x,y,z,w)
     *     satisfy x²+y²+z²+w² = 1
     *
     *         4D hypersurface
     *            _____
     *         .-'     '-.
     *       ,'           ',
     *      /               \
     *     |        O        |  (4D analog of sphere)
     *      \               /
     *       '.           .'
     *         '-.....-'
     * ```
     */
    class Sphere3Hopf {
        VdCorput vdc0;
        VdCorput vdc1;
        VdCorput vdc2;

      public:
        /**
         * @brief Construct a new Sphere 3 Hopf object
         *
         * @param[in] base0
         * @param[in] base1
         * @param[in] base2
         */
        Sphere3Hopf(const size_t base0, const size_t base1, const size_t base2)
            : vdc0(base0), vdc1(base1), vdc2(base2) {}

        /**
         * @brief pop
         *
         * The `pop()` function is used to generate the next value in the sequence.
         * In the `VdCorput` class, `pop()` increments the count and calculates the
         * Van der Corput sequence value for that count and base. In the `Disk`
         * class, `pop()` returns the next point in the Disk sequence as a
         * `std::array<double, 2>`. Similarly, in the `Circle` class, `pop()`
         * returns the next point on the unit circle as a `std::array<double, 2>`.
         * In the `Sphere` class, `pop()` returns the next point on the unit sphere
         * as a `std::array<double, 3>`. And in the `Sphere3Hopf` class, `pop()`
         * returns the next point on the 3-sphere using the Hopf fibration as a
         * `std::array<double, 4>`.
         *
         * @return std::array<double, 4>
         */
        auto pop() -> std::array<double, 4> {
            auto phi = this->vdc0.pop() * TWO_PI;  // map to [0, 2*pi];
            auto psy = this->vdc1.pop() * TWO_PI;  // map to [0, 2*pi];
            auto vdc = this->vdc2.pop();
            auto cos_eta = std::sqrt(vdc);
            auto sin_eta = std::sqrt(1.0 - vdc);
            return {
                cos_eta * std::cos(psy),
                cos_eta * std::sin(psy),
                sin_eta * std::cos(phi + psy),
                sin_eta * std::sin(phi + psy),
            };
        }

        /**
         * @brief Peek at the next value without advancing state
         *
         * @return std::array<double, 4> next point on the 3-sphere
         */
        [[nodiscard]] auto peek() -> std::array<double, 4> {
            auto phi = this->vdc0.peek() * TWO_PI;  // map to [0, 2*pi];
            auto psy = this->vdc1.peek() * TWO_PI;  // map to [0, 2*pi];
            auto vdc = this->vdc2.peek();
            auto cos_eta = std::sqrt(vdc);
            auto sin_eta = std::sqrt(1.0 - vdc);
            return {
                cos_eta * std::cos(psy),
                cos_eta * std::sin(psy),
                sin_eta * std::cos(phi + psy),
                sin_eta * std::sin(phi + psy),
            };
        }

        /**
         * @brief Generate multiple values efficiently
         *
         * @param[in] n number of values to generate
         * @return std::vector<std::array<double, 4>> vector of points
         */
        [[nodiscard]] auto batch(size_t n) -> std::vector<std::array<double, 4>> {
            std::vector<std::array<double, 4>> result;
            result.reserve(n);
            for (size_t i = 0; i < n; ++i) {
                result.push_back(this->pop());
            }
            return result;
        }

        /**
         * @brief Skip n values in the sequence
         *
         * @param[in] n number of values to skip
         */
        auto skip(size_t n) -> void {
            this->vdc0.skip(n);
            this->vdc1.skip(n);
            this->vdc2.skip(n);
        }

        /**
         * @brief reseed
         *
         * The `reseed(size_t seed)` function is used to reset the state of the
         * sequence generator to a specific seed value. This allows the sequence
         * generator to start generating the sequence from the beginning, or from a
         * specific point in the sequence, depending on the value of the seed.
         *
         * @param[in] seed
         */
        auto reseed(size_t seed) -> void {
            this->vdc0.reseed(seed);
            this->vdc1.reseed(seed);
            this->vdc2.reseed(seed);
        }

        /**
         * @brief Get current index
         *
         * @return size_t current index in sequence
         */
        [[nodiscard]] auto get_index() const -> size_t {
            return this->vdc0.get_index();
        }

        /**
         * @brief Get iterator to beginning
         *
         * @return GeneratorIterator<Sphere3Hopf, std::array<double, 4>>
         */
        auto begin() -> GeneratorIterator<Sphere3Hopf, std::array<double, 4>> {
            return GeneratorIterator<Sphere3Hopf, std::array<double, 4>>(this);
        }

        /**
         * @brief Get iterator to end (infinite sequence)
         *
         * @return GeneratorIterator<Sphere3Hopf, std::array<double, 4>>
         */
        [[nodiscard]] auto end() const -> GeneratorIterator<Sphere3Hopf, std::array<double, 4>> {
            return GeneratorIterator<Sphere3Hopf, std::array<double, 4>>(nullptr,
                                                                        std::numeric_limits<size_t>::max());
        }
    };

    extern size_t dummy(size_t index);
}  // namespace ldsgen
