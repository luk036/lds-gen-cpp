#pragma once

#include <memory>   // for unique_ptr
#include <cstddef>  // for size_t

// #include <algorithm>  // for std::transform
// #include <iterator>
#include <vector>  // for vector

#include "lds.hpp"  // for VdCorput, Sphere

namespace ldsgen {
    using std::vector;

    /**
     * @brief Halton(n) sequence generator
     *
     * The `HaltonN` class is a sequence generator that generates points in a
     * N-dimensional space using the Halton sequence. The Halton sequence is a
     * low-discrepancy sequence that is commonly used in quasi-Monte Carlo methods.
     * It is generated by iterating over two different bases and calculating the
     * fractional parts of the numbers in those bases. The `HaltonN` class keeps
     * track of the current count and bases, and provides a `pop()` method that
     * returns the next point in the sequence as a `std::vector<double>`.
     *
     * ```svgbob
     *     HaltonN([2,3,5]) sequence (3D):
     *     pop() -> [0.5, 0.333, 0.2]    (VdC bases [2,3,5])
     *     pop() -> [0.25, 0.666, 0.4]   (next in each sequence)
     *     pop() -> [0.75, 0.111, 0.6]   (etc...)
     *     ...
     * ```
     */
    class HaltonN {
      private:
        vector<std::unique_ptr<VdCorput>> vdcs;

      public:
        /**
         * @brief Construct a new Halton N object
         *
         * The `HaltonN(const vector<size_t> &base)` is a constructor for
         * the `HaltonN` class. It takes one parameter `base`, which is
         * used as the bases for generating the HaltonN sequence. The `explicit`
         * keyword indicates that this constructor can only be used for explicit
         * construction and not for implicit conversions.
         *
         * @param[in] base
         */
        explicit HaltonN(const vector<size_t>& base) {
            for (const auto& base_value : base) {
                this->vdcs.emplace_back(std::make_unique<ldsgen::VdCorput>(base_value));
            }
        }

        /**
         * @brief pop
         *
         * The `pop()` function is used to generate the next value in the sequence.
         * In the `VdCorput` class, `pop()` increments the count and calculates the
         * Van der Corput sequence value for that count and base. In the `HaltonN`
         * class, `pop()` returns the next point in the Halton sequence as a
         * `std::vector<double>`. Similarly, in the `Circle` class, `pop()` returns
         * the next point on the unit circle as a `std::array<double, 2>`. In the
         * `Sphere` class, `pop()` returns the next point on the unit sphere as a
         * `std::array<double, 3>`. And in the `Sphere3Hopf` class, `pop()` returns
         * the next point on the 3-sphere using the Hopf fibration as a
         * `std::array<double, 4>`.
         *
         * @return vector<double>
         */
        auto pop() -> vector<double> {
            auto res = vector<double>{};
            for (auto& vdc : this->vdcs) {
                res.emplace_back(vdc->pop());
            }
            return std::move(res);
        }

        /**
         * @brief reseed
         *
         * The `reseed(size_t seed)` function is used to reset the state of the
         * sequence generator to a specific seed value. This allows the sequence
         * generator to start generating the sequence from the beginning, or from a
         * specific point in the sequence, depending on the value of the seed.
         *
         * @param[in] seed
         */
        auto reseed(size_t seed) -> void {
            for (auto& vdc : this->vdcs) {
                vdc->reseed(seed);
            }
        }
    };

}  // namespace ldsgen
